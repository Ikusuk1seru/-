1. Як вирішено конфлікт бронювань? 

Я використав стандартну логіку перетину інтервалів на рівні SQL-запиту. Умова перетину двох відрізків часу [StartA, EndA] та [StartB, EndB] виглядає так: StartA < EndB AND EndA > StartB. Я додав це в filter SQLAlchemy разом із перевіркою status == 'active', щоб ігнорувати скасовані бронювання. Це гарантує атомарність перевірки та цілісність даних.

2. Як працює Availability? 

Алгоритм працює наступним чином:
Генерація: Ми беремо робочий час (наприклад, 09:00 - 18:00) і "нарізаємо" його на віртуальні шматочки по slot_minutes (наприклад, по 30 хв).
Вибірка: Завантажуємо з БД всі активні бронювання для цього ресурсу, які зачіпають цей день.
Фільтрація: Проходимо циклом по згенерованих слотах. Якщо слот перетинається (та сама формула перетину) з будь-яким існуючим бронюванням, ми його викидаємо.

Результат: Повертаємо тільки ті слоти, які "вижили" після перевірки.
